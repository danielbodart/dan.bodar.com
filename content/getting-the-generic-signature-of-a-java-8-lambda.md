---
title: "Getting the generic signature of a Java 8 lambda"
date: 2014-09-01T21:02:03Z
slug: "getting-the-generic-signature-of-a-java-8-lambda"
categories:
  - Uncategorized
comments:
  - {"author":"Java Weekly 31/15: HTTP/2 in Java9, JMS 2, DevoxxUK","email":"","url":"http://www.thoughts-on-java.org/java-weekly-3115-http2-java9-jms-2-devoxxuk/","date":"2015-07-27T03:40:23Z","content":"[…] stumbled upon an old but interesting post explaining how to get the generic signature of a lambda expression. As Daniel Worthington-Bodart shows in this post, it is possible to get these information […]","parent":0}
---

<a href="http://stackoverflow.com/a/25612775/1000974">Posted to StackOverflow</a>

This is currently possible to solve but only in a pretty hackie way, but let me first explain a few things:

When you write a lambda, the compiler inserts a dynamic invoke instruction pointing to the <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/invoke/LambdaMetafactory.html">LambdaMetafactory</a> and a private static synthetic method with the body of the lambda. The synthetic method and the method handle in the constant pool both contain the generic type (if the lambda uses the type or is explicit as in your examples).

Now at runtime the LambdaMetaFactory is called and a class is generated using ASM that implements the functional interface and the body of the method then calls the private static method with any arguments passed. It is then injected into the original class using Unsafe.defineAnonymousClass
(see <a href="https://blogs.oracle.com/jrose/entry/anonymous_classes_in_the_vm">John Rose post</a>) so it can access the private members etc.

Unfortunately the generated Class does not store the generic signatures (it could) so you can't use the usual reflection methods that allow you to get around erasure

For a normal Class you could inspect the bytecode using Class.getResource(ClassName + ".class")
but for anonymous classes defined using Unsafe you are out of luck. However you can make the LambdaMetaFactory
dump them out with the JVM argument:
<pre>java -Djdk.internal.lambda.dumpProxyClasses=/some/folder</pre>
By looking at the dumped class file (using javap -p -s -v), one can see that it does indeed call the static method. But the problem remains how to get the bytecode from within Java itself.

<strong>This unfortunately is where it gets hackie:</strong>

Using reflection we can call Class.getConstantPool and then access the MethodRefInfo to get the type descriptors. When can then use ASM to parse this and return the argument types. Putting it all together:
<pre>Method getConstantPool = Class.class.getDeclaredMethod("getConstantPool");
getConstantPool.setAccessible(true);
ConstantPool constantPool = (ConstantPool) getConstantPool.invoke(lambda.getClass());
String[] methodRefInfo = constantPool.getMemberRefInfoAt(constantPool.size() - 2);

int argumentIndex = 0;
String argumentType = jdk.internal.org.objectweb.asm.Type.getArgumentTypes(methodRef[2])[argumentIndex].getClassName();
Class<?> type = (Class<?>) Class.forName(argumentType);</pre>
Now ideally the classes generated by LambdaMetaFactory should store the generic type signatures (I might see if I can submit a patch to the OpenJDK) but currently this is the best we can do. The code above has the following problems:
<ul>
	<li>It uses undocumented methods and classes</li>
	<li>It is extremely vulnerable to code changes in the JDK</li>
	<li>It doesn't preserve the generic types, so if you pass List into a lambda it will come out as List</li>
</ul>